<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>物联网操作系统AliOS Things 3.3: 构建配置 package.yaml</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">物联网操作系统AliOS Things 3.3
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('packageyaml_user_manual.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">构建配置 package.yaml </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>package.yaml是组件的配置文件，采用yaml文本的方式，配置组件包含哪些源文件，头文件，宏，以及组件依赖关系等等，替代了传统的makefile文件。 </p>
<h1><a class="anchor" id="autotoc_md222"></a>
构建规则说明</h1>
<p>yaml语法说明：<a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">https://www.ruanyifeng.com/blog/2016/07/yaml.html</a><br  />
<a href="https://yaml.org/spec/1.2/spec.html">https://yaml.org/spec/1.2/spec.html</a><br  />
 <br  />
yaml格式校验工具：<a href="https://www.bejson.com/validators/yaml_editor/">https://www.bejson.com/validators/yaml_editor/</a><br  />
 <br  />
package.yaml模板生成：<br  />
在aos**工作目录**下使用。 当用户想把一个源码目录快速变为一个aos组件时，将组件代码复制到aos内相应的组件目录下，然后使用这个命令，会在<code>&lt;dir&gt;</code>目录下生成<code>package.yaml</code>文件模板，用户可根据需求再适当的调整修改<code>package.yaml</code>文件。 </p><div class="fragment"><div class="line">aos convert &lt;dir&gt;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md223"></a>
构建文件字段说明</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">package.yaml   </th><th class="markdownTableHeadNone">必选   </th><th class="markdownTableHeadNone">说明    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>基本信息</b>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">name   </td><td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">包名称 （符合C语言变量命名规则），长度少于等于64字节    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">description   </td><td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">简洁直白用一句完成组件介绍    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">version   </td><td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">组件版本号，**版本号必须与组件代码仓库的branch或者tag保持一致**。    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">type   </td><td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">组件类型，为：<br  />
solution，board，chip，arch ，drv_core，drv_peripheral， drv_external_device， kernel， common<br  />
solution组件放在solutions目录下；<br  />
board，chip，arch组件放在hardware目录下；<br  />
drv_core，drv_peripheral， drv_external_device组件放在components/drivers目录下；<br  />
kernel组件放在kernel目录下；<br  />
common组件放在components目录下。    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tag   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">组件分类，缺省值： "''。可以写中文，与代码目录结构和编译无关。    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">keywords   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">标签，会影响到组件被搜索的效果，合理的标签很重要    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">author   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">原作者信息和维护人员信息    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">license   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">源代码的许可证，要确保所有代码、文件的许可证不冲突。    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">homepage   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">组件的主页    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">**依赖关系**   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">depends<br  />
&#160; - comp1: "v1.0"   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">指定该组件依赖的组件及版本，目前仅支持指定版本：如v1.0。后续将支持&gt;=v1.0, &gt;v1.0, ==v1.0, &lt;=v1.0, &lt;v1.0, !=v1.0等，并且需要用“”号括起来。<br  />
组件的版本请查询组件的package.yaml里面的version字段。<br  />
**注：对于solution的组件，可以依赖多个board组件。由board_name指定本次构建所采用的组件。**    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">depends<br  />
&#160; - comp1: "v1.0 ? &lt;COND&gt;"   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">条件依赖，当条件COND=1时，才引入该组件。条件由下文的def_config中宏指定。<br  />
如果该条件未定义，不会引入该组件。<br  />
注意“”号的写法，包含了版本号和条件。    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">aos_version   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">组件支持的 OS 的基线版本，缺省值：支持所有版本的OS    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">**板级信息**   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">**注：AliOS Things暂时不考虑异构多CPU的情况**    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">solution板级配置   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">board_name   </td><td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">指定开发板组件名，未设置时，使用depends中 board 第一个组件    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cpu_id   </td><td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">cpu编号，固定为cpu0。    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ld_script   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">链接时使用的 LD 脚本，未设置时，使用对应的 board 的 LD 脚本    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">board板级配置   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">chip_name   </td><td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">指定芯片组件名    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ld_script   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">链接时使用 的LD 脚本，未设置时，使用对应的 chip 的 LD 脚本    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">chip板级配置   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cpu_name   </td><td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">该芯片使用的 CPU 型号    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ld_script   </td><td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">链接时使用 的LD 脚本    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">arch_name   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">芯片架构名称    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">flash_program   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">芯片 FLASH 烧写程序    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program_data_files<br  />
 - filename: 11.bin <br  />
 address: 0xB32000<br  />
 - filename: 22.bin <br  />
 address: 0xB52000   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">aos burn默认会烧录编译出来的bin文件，如果需要额外烧录其它文件，可以使用program_data_files配置1个或多个文件。<br  />
filename：文件名<br  />
address: 烧录起始地址    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">toolchain_prefix   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">编译器前缀，例如：csky-abiv2-elf。未指定时，根据 cpu_name 来推断编译器前缀    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">**编译链接信息**   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">include   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">组件对外的公共头文件所在的目录，只能是该软件包下的目录，**不能使用外部目录，不能使用外部目录，不能使用外部目录**<br  />
**对外的头文件目录尽量少于3个**    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">internal_include   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">组件内部使用的头文件所在的目录    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cflag   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">该组件&#160;C 编译器所需要要的编译参数    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cxxflag   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">该组件&#160;C++ 编译器所需要要的编译参数    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">asmflag   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">该组件&#160;汇编 编译器所需要要的编译参数    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">define<br  />
&#160; AAA: 1<br  />
&#160; STR: "abc"   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">该组件内的宏定义<br  />
以**key: value**方式罗列<br  />
**不支持**后续加条件，如~~AAA: 1 ? &lt;COND&gt;~~    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">libs<br  />
&#160; - lib1.a   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">该组件中支持的二进制静态库<br  />
以**数组**方式罗列    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">libs<br  />
&#160; - lib1.a ? &lt;COND&gt;<br  />
&#160; - lib2.a ? &lt;!COND&gt;   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">根据条件，引入该组件中支持的二进制静态库<br  />
**仅包含一个条件**，但是可使用**not**逻辑，即!COND，当COND为0时，引入lib1.a<br  />
**不需要加引号“”；或者整个加引号，如“**lib1.a ? &lt;COND&gt;**”**    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">libpath   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">指定静态库所在的路径（相对于该组件路径）    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">source_file<br  />
&#160; - src/*.c   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">指定参与编译的源代码文件，支持通配符，采用相对路径    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">source_file<br  />
&#160; - src/xx.c ? &lt;COND&gt;   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">根据条件，引入源代码文件<br  />
仅包含一个条件，但是可使用not逻辑，即!COND，当COND为0时，引入src/xx.c<br  />
**不需要加引号“”；或者整个加引号，如“**lib1.a ? &lt;COND&gt;**”**    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cflag   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">chip、board或者solution组件里的C编译器选项    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cxxflag   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">chip、board或者solution组件里的C++编译器选项    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">asmflag   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">chip、board或者solution组件里的汇编编译器选项    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ldflag   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">chip、board或者solution组件里的链接选项    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">prebuild_script   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">组件编译前执行的脚本文件（带参数运行，参数包含toolchain名称，lib库名称，组件defconfig等）<br  />
脚本文件可**直接运行**，包含x属性，脚本第一行用#!指明运行脚本的程序，如#!/usr/bin/evn python<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">postbuild_script   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">组件编译后执行的脚本文件（带参数运行，参数包含toolchain名称，lib库名称，和组件defconfig等）<br  />
脚本文件可**直接运行**，包含x属性，脚本第一行用#!指明运行脚本的程序，如#!/usr/bin/evn python    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">postimage_script   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">构建image后执行的脚本文件（带参数运行，参数包含toolchain名称，elf名称）<br  />
脚本文件可**直接运行**，包含x属性，脚本第一行用#!指明运行脚本的程序，如#!/usr/bin/evn python    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">**配置信息**   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">def_config   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">组件的可配置项。<br  />
当 common 组件、chip 组件、board 组件、solution 组件都存在相同配置时，优先顺序为 :solution &gt; board &gt; chip &gt; arch &gt; (drv_core, drv_peripheral, drv_external_device) &gt; kernel &gt; common<br  />
**上文中所提到的COND，在组件的def_config中定义，取值为0或1**    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">**安装信息**   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">导出sdk时使用，将头文件和库文件安装到指定目录，提供给二次开发者。    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dest   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">安装的目的路径 dest是相对路径，通常是相对于AOS 安装目录    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">source   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">安装源列表，支持通配符，相对路径<br  />
详细说明请参考《aos-tools用户手册》。   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md224"></a>
附录</h1>
<h2><a class="anchor" id="autotoc_md225"></a>
prebuild、postbuild、postimage脚本示例</h2>
<p>aos-tools可运行外部脚本，并以"--longopt=value"的方式传入参数：</p>
<ul>
<li>prebuild_script: 在组件编译之前运行</li>
<li>postbuild_script: 在组件编译完成之后运行</li>
<li>postimage_script: 在工程构建完成之后运行 </li>
</ul>
<h3><a class="anchor" id="autotoc_md226"></a>
python版本</h3>
<div class="fragment"><div class="line">#!/usr/bin/env python</div>
<div class="line">import os, sys, re, codecs</div>
<div class="line"> </div>
<div class="line">params = sys.argv[1:]</div>
<div class="line">if os.path.isfile(sys.argv[1]):</div>
<div class="line">    with codecs.open(sys.argv[1], &#39;r&#39;, &#39;UTF-8&#39;) as fh:</div>
<div class="line">        params = fh.read().split()</div>
<div class="line"> </div>
<div class="line"># choose those arguments we wanted, and discard others</div>
<div class="line">key_value = {}</div>
<div class="line">pattern = re.compile(r&#39;--(.+?)=(.*)&#39;)</div>
<div class="line">for arg in params:</div>
<div class="line">    if arg.startswith(&quot;--&quot;):</div>
<div class="line">        match = pattern.match(arg)</div>
<div class="line">        if match:</div>
<div class="line">            key = match.group(1)</div>
<div class="line">            value = match.group(2)</div>
<div class="line">            if key in [&quot;toolchain&quot;, &quot;lib&quot;, &quot;target&quot;]:</div>
<div class="line">                key_value[key] = value</div>
<div class="line"> </div>
<div class="line">print(&quot;the script is %s&quot; % sys.argv[0])</div>
<div class="line">print(&quot;current dir is %s&quot; % os.getcwd())</div>
<div class="line">for key in key_value.keys():</div>
<div class="line">    print(&quot;%s is %s&quot; %(key, key_value[key]))</div>
<div class="line"> </div>
<div class="line"># =======================================================</div>
<div class="line"># do our work</div>
<div class="line"> </div>
<div class="line"># =======================================================    </div>
<div class="line"> </div>
<div class="line"># result</div>
<div class="line">print(&quot;run external script success&quot;)</div>
<div class="line">exit(0)</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md227"></a>
shell版本</h3>
<div class="fragment"><div class="line">#!/usr/bin/env bash</div>
<div class="line"> </div>
<div class="line">if [ &quot;$(uname)&quot; == &quot;Darwin&quot; ]; then</div>
<div class="line">    os=&quot;Darwin&quot;</div>
<div class="line">elif [ &quot;$(expr substr $(uname -s) 1 5)&quot; == &quot;Linux&quot; ]; then   </div>
<div class="line">    os=&quot;Linux&quot;</div>
<div class="line">elif [&quot;$(expr substr $(uname -s) 1 10)&quot;==&quot;MINGW32_NT&quot;];then    </div>
<div class="line">    os=&quot;Win32&quot;</div>
<div class="line">fi</div>
<div class="line">echo &quot;os is $os&quot;</div>
<div class="line"> </div>
<div class="line">if [ -f $1 ]; then</div>
<div class="line"># read arguments from file, and choose those arguments we wanted</div>
<div class="line">for word in $(&lt;$1)</div>
<div class="line">do</div>
<div class="line">    key=$(echo $word | cut -d &#39;=&#39; -f1)</div>
<div class="line">    if [ &quot;$os&quot; == &quot;Darwin&quot; ]; then</div>
<div class="line">        value=$(echo $word | cut -d &#39;=&#39; -f2-)</div>
<div class="line">    elif [ &quot;$os&quot; == &quot;Linux&quot; ]; then</div>
<div class="line">        value=$(echo $word | cut -d &#39;=&#39; --complement -f1)</div>
<div class="line">    else</div>
<div class="line">        value=&quot;&quot;</div>
<div class="line">    fi</div>
<div class="line">    case &quot;$key&quot; in</div>
<div class="line">        --toolchain) toolchain=$value;;</div>
<div class="line">        --lib) lib=$value;;</div>
<div class="line">        --target) target=$value;;</div>
<div class="line">        *) echo &quot;discard option $word&quot;;;</div>
<div class="line">    esac;</div>
<div class="line">done</div>
<div class="line">else</div>
<div class="line"># choose those arguments we wanted, and discard others</div>
<div class="line">until [ $# -eq 0 ]</div>
<div class="line">do</div>
<div class="line">    key=$(echo $1 | cut -d &#39;=&#39; -f1)</div>
<div class="line">    value=$(echo $1 | cut -d &#39;=&#39; --complement -f1)</div>
<div class="line">    case &quot;$key&quot; in</div>
<div class="line">        --toolchain) toolchain=$value;shift;;</div>
<div class="line">        --lib) lib=$value;shift;;</div>
<div class="line">        --target) target=$value;shift;;</div>
<div class="line">        *) echo &quot;discard option $1&quot;;shift;;</div>
<div class="line">    esac;</div>
<div class="line">done</div>
<div class="line">fi</div>
<div class="line"> </div>
<div class="line">echo &quot;the script is $0&quot;</div>
<div class="line">echo &quot;current dir is $(pwd)&quot;</div>
<div class="line">echo &quot;toolchain is $toolchain&quot;</div>
<div class="line">echo &quot;lib is $lib&quot;</div>
<div class="line">echo &quot;target is $target&quot;</div>
<div class="line"> </div>
<div class="line"># =======================================================</div>
<div class="line"># do our work</div>
<div class="line"> </div>
<div class="line"># =======================================================</div>
<div class="line"> </div>
<div class="line"># result</div>
<div class="line">echo &quot;run external script success&quot;</div>
<div class="line">exit 0</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md228"></a>
制作二次开发SDK</h2>
<ul>
<li><p class="startli">编写package.yaml</p>
<p class="startli">&#160;在各个组件内部，将需要导出的h文件和预编译库添加到package.yaml的install部分。添加规则如下：<br  />
例如某个组件A的实际的文件列表如下： </p><div class="fragment"><div class="line">compa</div>
<div class="line">├── package.yaml</div>
<div class="line">├── README.md</div>
<div class="line">├── src</div>
<div class="line">│   ├── aaa.c</div>
<div class="line">│   ├── bbb.c</div>
<div class="line">│   ├── ccc.c</div>
<div class="line">│   └── ddd.c</div>
<div class="line">├── include</div>
<div class="line">│   ├── aaa.h</div>
<div class="line">│   ├── bbb.h</div>
<div class="line">│   └── fff</div>
<div class="line">│       └── ccc.h</div>
<div class="line">└── interal_include</div>
<div class="line">│    └── ddd.h</div>
<div class="line">└── prebuilt</div>
<div class="line">     └── libeeeee.a</div>
</div><!-- fragment --><p> 的 <code>build_confg</code>部分指定了对外头文件和预编译库： </p><div class="fragment"><div class="line">build_config:</div>
<div class="line">  include:</div>
<div class="line">    - include/</div>
<div class="line">  libs:</div>
<div class="line">    - eee</div>
<div class="line">  libpath:</div>
<div class="line">    - prebuilt</div>
</div><!-- fragment --><p> 那么install部分如下，其中头文件都放在Include目录下，预编译库都放在lib目录下。 </p><div class="fragment"><div class="line">install:</div>
<div class="line">  # copy aaa.h bbb.h to aos_sdk/include</div>
<div class="line">  - dest: &quot;include&quot;</div>
<div class="line">    source:</div>
<div class="line">      - *.h</div>
<div class="line">  # copy fff/ccc.h to aos_sdk/include/fff</div>
<div class="line">  - dest: &quot;include/fff&quot;</div>
<div class="line">    source:</div>
<div class="line">      - fff/*.h</div>
<div class="line">  # copy drivers/libmcuhaas1000.a to aos_sdk/lib/libmcuhaas1000.a</div>
<div class="line">  - dest: &quot;lib&quot;</div>
<div class="line">    source:</div>
<div class="line">      - prebuilt/libeee.a</div>
</div><!-- fragment --></li>
<li>在solution目录下执行编译，aos make，编译成功后会将组件编译生成的静态库自动放到aos_sdk/lib目录下。</li>
<li>在solution目录下执行导出，aos sdk，将组件对外头文件和预编译库复制到aos_sdk里的include和lib目录下。</li>
<li>删除out目录，将当前solution目录打包，提供给其他开发者做二次开发。 </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">生成于 2021年 四月 21日 星期三 14:19:01 , 为 物联网操作系统AliOS Things 3.3使用  <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
